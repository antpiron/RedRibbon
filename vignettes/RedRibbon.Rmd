---
title: "RedRibbon: a rank-rank hypergeometric overlap library"
author: "Anthony Piron, Theodora Papadopoulou"
date: "`r Sys.Date()`"
abstract: >
  High throughput omics technologies have generated a wealth of large protein, gene and transcript datasets 
  that have exacerbated the need for new methods to analyse and compare big datasets. Rank-rank hypergeometric 
  overlap is an important threshold-free method to combine and visualize two ranked lists of P-values or fold-changes, 
  usually from differential gene expression analyses. Here, we introduce a new rank-rank hypergeometric overlap-based 
  method aimed at gene, transcript, exon and protein level capable of taking into account alternative splicing phenomena.
  It offers the possibility to compare these levels to each other, hitherto unreachable as transcript and protein numbers
  are an order of magnitude larger than gene numbers.
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{RedRibbon}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
library(kableExtra)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "80%",
  fig.width = 8,
  fig.height = 8,
  fig.align = "center"
)
```


RedRibbon is a comparative analysis tool of omics differential analyses. 
It allows to determine the features overlapping between two differential studies. 
It features high performance, accuracy and simplicity in use. RedRibbon has been optimized to be efficient regardless of the length of the lists given as input. 
The input data for RedRibbon are two labelled ranked lists of real numbers under comparison. 
These two lists could contain proteins, gene or transcript ranked by a statistic such as log fold change or direction signed P-value. 
Optionally, the minimal P-value can be adjusted considering expression level correlation between genes or transcripts.

If you have issues with the `RedRibbon` package, please submit it on the [RedRibbon github issue reporting system](https://github.com/antpiron/RedRibbon/issues) and
we will make our best to address your problems. 

To demonstrate RedRibbon's basic workflow, we will first generate and use a synthetic data set. Next, the tool will be applied on [real data sets](#realdataset). 
We recommend you to read first this simple experimental section to familiarize yourself with the tool before applying it to your real data.
Each of the functions or methods described in this R vignette is fully documented. 
This documentation can be access the usual way in R with the question mark prefixing the function name (e.g., `?RedRibbon.data.frame`).

# Synthetic data set

The synthetic data set is composed of two labeled lists of numbers. A `data.frame`, called `df`, will contain these lists. 
This `data.frame` is composed of columns `a` and `b`, the two lists of numbers and `id`, a list of labels. 
Those columns are mandatory to run RedRibbon rank-rank hyper-geometric overlap. The synthetic lists have
one quarter perfectly overlapping at the bottom of the list, one quarter at the top of the list, and the remaining elements are random. 

The code to generate those lists in the `data.frame` `df` is 

```{r dataset, results='hide'}
set.seed(42)
n <- 1000
n2 <- n %/% 2
n4 <- n %/% 4
a <- (1:n) - n2
b <- a
a[n4:(n4+n2-1)] <- rnorm(n2, sd=100)
b[n4:(n4+n2-1)] <- rnorm(n2, sd=100)
df <- data.frame(
	id = paste0("gene", 1:n),
	a = a,
	b = b)
```

The first lines of the `data.frame` (as given by `head(df)`) are
	
```{r df, echo=FALSE}
head(df) %>%
  kbl() %>%
  kable_styling()
```

## Overlapping

We will now compute an overlap with RedRibbon for this synthetic data set. First, the library is loaded with

```{r Library loading}
library(RedRibbon)
```

First, we create a a S3 RedRibbon object with the `RedRibbon` function,

```{r s3, results='hide'}
rr <- RedRibbon(df, enrichment_mode="hyper-two-tailed")
```

We set the parameter `enrichment_mode` to use two-tailed test. 
This way, we will simultaneously detect enrichment in correlated (up/up and down/down) and anti-correlated (up/down and down/up) genes.

Next, we localize the minimal P-value in the four quadrants with the `quadrants` method on the RedRibbon object,

```{r enrichment, results='hide'}
quad <- quadrants(rr, algorithm="ea", permutation=TRUE, whole=FALSE)
```

We use the evolutionary algorithm (`algorithm="ea"`) to locate the minimal p-value coordinates with the highest accuracy).
We also ask the computation of adjusted p-value with the `permutation` option to `TRUE`. 
`whole`=`FALSE` splits the overlap map into four quadrants (i.e., down-down, up-up, down-up, up-down).

<a name="ggRedRibbon"/>
## Plotting the level map

Results can be plotted with the helper function `ggRedRibbon`. The overlap map of the two lists goes respectively in the same direction (both downregulated
or both upregulated in the 2 lists). The maximal log P-values and the permutation adjusted P-values are shown for each quadrant. The horizontal and vertical
dotted lines split the downregulation and upregulation where the log fold change is zero. The code to produce the map is straightforward,

```{r ggplot}
gg <- ggRedRibbon(rr, quadrants=quad,
		  repel.force = 250) +
		  coord_fixed(ratio = 1, clip = "off")
gg
```

In the overlap map, the hypergeometric P-value are signed negatively for depletion (anti-correlation) and positive for enrichment (correlation).

The `gg` variable contains a standard ggplot2 object,

```{r class ggplot}
class(gg)
```

Hence, this object can be manipulated as any ggplot object.
For example, in this vignette we used `+ coord_fixed(ratio = 1)` to obtain a fixed scale of coordinates (see `?ggplot2::coord_fixed`).


## Enrichment statistics

The lists of overlapping genes are returned by the `quadrants` method. 
The list of genes enriched in the down-down direction is given by `df[quad$downdown$positions,]`

```{r genes, echo=FALSE}
head(df[quad$downdown$positions,])  %>%
  kbl() %>%
  kable_styling()
```

`quad$downdown$positions` is a vector of indices in the `df` `data.frame`. 
The other quadrants indices are given in `quad$upup$positions`, `quad$downup$positions`, and `quad$updown$positions`.


You may also easily access to all the statistics generated by the analysis:

```{r names}
names(quad$downdown)
```

```{r values}
quad$downdown[c("i", "j", "pvalue", "log_pvalue", "count", "direction")]
```

`(i , j)` is the  minimal p-value coordinate on the enrichment map, `pvalue` and `log_pvalue` are the minimal p-value, `direction` is the direction of the enrichment.
`count` is the number of genes overlapping.

## Compatibility mode

This mode only exists for compatibility with [RRHO](https://www.bioconductor.org/packages/release/bioc/html/RRHO.html). Please use the new interface shown above when possible.

```{r compat}
compat <- RRHO(df[,c("id", "a")], df[,c("id", "b")], plots=TRUE, stepsize=n %/% 10)
compat$gg
```

```{r hypermat, results='hide'}
compat$hypermat
```

```{r hypermat2, echo=FALSE}
compat$hypermat %>%
  kbl(digits = 2) %>%
  kable_styling()
```

For the description of these field and parameters, we refer the reader to the `RRHO` package documentation.

## Using and computing correlation between genes

To demonstrate how we use the correlation of expression between genes, we will generate an artificial expression matrix of `n.genes x n.samples` associated to a fold change between
the 2 conditions (e.g., treated vs non-treated samples). The first five genes are perfectly correlated.

```{r correlation dataset} 
gen.expression.matrix <- function (n.genes, n.samples, fc=NULL, r = NULL)
{
	n.treated <- n.samples %/% 2
	n.non.treated <- n.samples - n.treated
	
	mat.non.treated <- matrix( rnorm(n.genes * n.non.treated, sd=10), nrow = n.genes)
	mat.fc <- if (is.null(fc)) 0 else mat.non.treated * fc
	mat.treated <- matrix(mat.fc + rnorm(n.genes * n.non.treated, sd=10) , nrow = n.genes)
	mat <- cbind(
		         mat.non.treated,
		         mat.treated)
	if ( ! is.null(r) )
	{
           for (i in 2:(length(r)+1) )
	     {
	        mat[i, ] <- mat[1,] * r[i-1] + (1-abs(r[i-1])) * mat[i, ]
	     }	
	}
    mat
}

n <- 50
n.frac <- 5
fc_a <- c(rep(-2, n.frac), runif(n-n.frac, -2, 2))
fc_b <- c(rep(-2, n.frac), runif(n-n.frac, -2, 2))
df <- data.frame(a=fc_a, b=fc_b)

mat_b <- gen.expression.matrix(n, 6, fc=fc_b, r=c(1, 1, 1, 1))

head(mat_b)
```

We can then compute the correlation,

```{r correlation compute} 
correlation <- rrho_expression_prediction(mat_b)
c.obj <- newFC(correlation$index, correlation$beta[,2])
c.obj
```

And input the computed correlation in `RedRibbon`

```{r use correlation} 
rr <- RedRibbon(df, enrichment_mode="hyper-two-tailed", correlation=c.obj)
quad <- quadrants(rr, algorithm="ea", permutation=TRUE, whole=FALSE)
gg <- ggRedRibbon(rr, quadrants=quad,
		  repel.force = 250) +
   coord_fixed(ratio = 1, clip = "off")
gg

```

Considering gene correlations, the adjusted p-value of the overlap is not significant. Hence, no minimal coordinate is shown on the map.

<a name="realdataset"/>

# Analysis with real data sets



## Transcriptomic analyses overlap

To demonstrate the capabilities of `RedRibbon`, we will use data from a ([real example.](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE159984)).
The data contains the output from 2 different differential expression analysis obtained with `DeSeq2`. In this case, columns `a` and `b` contain log2FoldChange
values corresponding to type 2 diabetes signatures and human islets threated with palmitate and glucose (D8PG) signatures. 

```{r mergeT2DD8PG}
data("T2D-D8PG", package = "RedRibbon")

df.real <- merge(T2DvsCTL[, c("ensembl_id", "log2FoldChange")],
                 D8PGvsCTL[, c("ensembl_id", "log2FoldChange")],
		 by = "ensembl_id")
colnames(df.real) <- c("id", "a", "b")
head(df.real) %>%
  kbl() %>%
  kable_styling()
```

Once the data is formatted, we can run `RedRibbon`. `RedRibbon` function constructs the object, which  will be used by `quadrants` to compute the best coordinates.
All the steps performed by `RedRibbon` and `quadrants` are described in the RedRibbon manuscript. `ggRedRibbon` will plot the RRHO map.

```{r RedRibbonT2DD8PG}
rr <- RedRibbon(df.real, enrichment_mode="hyper-two-tailed")
quad <- quadrants(rr, algorithm="ea", permutation=TRUE, whole=FALSE)
gg <- ggRedRibbon(rr, quadrants=quad,
      		  labels = c("T2D vs CTL", "D8PG vs CTL"),
		  repel.force = 250) +
   coord_fixed(ratio = 1, clip = "off")
gg

```

## Long read analysis compared to short read analysis


## Proteomic analysis vs transcriptomic analysis

# sessionInfo()

```{r sessionInfo} 
sessionInfo()
```
