---
title: "RedRibbon: a rank-rank hypergeometric overlap library"
author: "Anthony Piron"
date: "`r Sys.Date()`"
abstract: >
  High throughput omics technologies have generated a wealth of large protein, gene and transcript datasets 
  that have exacerbated the need for new methods to analyse and compare big datasets. Rank-rank hypergeometric 
  overlap is an important threshold-free method to combine and visualize two ranked lists of P-values or fold-changes, 
  usually from differential gene expression analyses. Here, we introduce a new rank-rank hypergeometric overlap-based 
  method aimed at both gene level and alternative splicing analyses at transcript or exon level, 
  hitherto unreachable as transcript numbers are an order of magnitude larger than gene numbers.
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    fig_width: 5
  rmarkdown::pdf_document:
    toc: true
    fig_pos: H
    extra_dependencies: ["float"]
vignette: >
  %\VignetteIndexEntry{RedRibbon}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(kableExtra)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "80%",
  fig.width = 8,
  fig.height = 8,
  fig.align = "center",
  fig.pos = "H"
)
```

# Analysis with a synthetic dataset

To demonstrate RedRibbon's basic workflow, we will first work with synthetic dataset (For real data, skip to section [Real data set](#realdataset)).

## Generate a synthetic dataset

We build a `data.frame` with the mandatory `a` and `b` columns. Those columns are the two lists over which the rank-rank hyper-geometric overlap is run.

```{r dataset, results='hide'}
set.seed(42)
n <- 1000
n2 <- n %/% 2
n4 <- n %/% 4
a <- (1:n) - n2
b <- a
a[n4:(n4+n2-1)] <- rnorm(n2, sd=100)
b[n4:(n4+n2-1)] <- rnorm(n2, sd=100)
df <- data.frame(
	id = paste0("gene", 1:n),
	a = a,
	b = b)
```

`df` data frame contains half features perfectly matching perfectly between `a` and `b` and the remaining elements are random, `head(df)` gives
	
```{r df, echo=FALSE}
head(df) %>%
  kbl() %>%
  kable_styling(latex_options = "hold_position")
```

## Synopsis

Load the library with

```{r Library loading}
library(RedRibbon)
```

Create an S3 RedRibbon object,

```{r s3, results='hide'}
rr <- RedRibbon(df, enrichment_mode="hyper-two-tailed")
```

Compute the enrichment and adjusted p-value with the `permutation` option set to compute the adjusted p-value and `whole` to split the overlap map into four quadrants (i.e., down-down, up-up, down-up, up-down),

```{r enrichment, results='hide'}
quad <- quadrants(rr, algorithm="ea", permutation=TRUE, whole=FALSE)
```

## Plotting the level map

Results can be plotted with the helper function `ggRedRibbon`:

```{r ggplot}
gg <- ggRedRibbon(rr, quadrants=quad,
		  repel.force = 250) +
		  coord_fixed(ratio = 1, clip = "off")
gg
```

The `gg` variable contains a standard ggplot2 object,
```{r class ggplot}
class(gg)
```

It can be manipulated as such. For example, in this vignette we used `+ coord_fixed(ratio = 1)` to obtain a fixed scale of coordinates (see `ggplot2::coord_fixed`).


## Enrichment statistics

List(s) of enriched genes can be accessed within the `RedRibbon` object. For example, you may access the list of genes enriched in the down-down direction with `df[quad$downdown$positions,]`
```{r genes, echo=FALSE}
head(df[quad$downdown$positions,])  %>%
  kbl() %>%
  kable_styling(latex_options = "hold_position")
```

You may also easily access to all the statistics generated by the analysis:

```{r names}
names(quad$downdown)
```

`(i , j)` is the  minimal p-value coordinate on the enrichment map, `pvalue` and `log_pvalue` are the minimal p-value, `direction` is the direction of the enrichment (same direction is postive -- up-up, down-down --, opposite is negative -- down-up, up-down) and `count` is the number of genes overlapping.

## Compatibility mode

This mode only exists for compatibility with [RRHO](https://www.bioconductor.org/packages/release/bioc/html/RRHO.html) and is obsolete. Please use the new interface shown here above.

```{r compat}
compat <- RRHO(df[,c("id", "a")], df[,c("id", "b")], plots=TRUE, stepsize=n %/% 10)
compat$gg
```

```{r hypermat, results='hide'}
compat$hypermat
```
```{r hypermat2, echo=FALSE}
compat$hypermat %>%
  kbl(digits = 2) %>%
  kable_styling(latex_options = "hold_position")
```


## Using and computing correlation between genes

To demonstrate how we use the correlation of expression between genes, we will generate an artificial expression matrix of `n.genes x n.samples` associated to a fold change between the 2 conditions (e.g., treated vs non-treated samples). The first five genes are perfectly correlated.

```{r correlation dataset} 
gen.expression.matrix <- function (n.genes, n.samples, fc=NULL, r = NULL)
{
	n.treated <- n.samples %/% 2
	n.non.treated <- n.samples - n.treated
	
	mat.non.treated <- matrix( rnorm(n.genes * n.non.treated, sd=10), nrow = n.genes)
	mat.fc <- if (is.null(fc)) 0 else mat.non.treated * fc
	mat.treated <- matrix(mat.fc + rnorm(n.genes * n.non.treated, sd=10) , nrow = n.genes)
	mat <- cbind(
		         mat.non.treated,
		         mat.treated)
	if ( ! is.null(r) )
	{
           for (i in 2:(length(r)+1) )
	     {
	        mat[i, ] <- mat[1,] * r[i-1] + (1-abs(r[i-1])) * mat[i, ]
	     }	
	}
    mat
}

n <- 50
n.frac <- 5
fc_a <- c(rep(-2, n.frac), runif(n-n.frac, -2, 2))
fc_b <- c(rep(-2, n.frac), runif(n-n.frac, -2, 2))
df <- data.frame(a=fc_a, b=fc_b)

mat_b <- gen.expression.matrix(n, 6, fc=fc_b, r=c(1, 1, 1, 1))

head(mat_b)
```
We can then compute the correlation:

```{r correlation compute} 
correlation <- rrho_expression_prediction(mat_b)
c.obj <- newFC(correlation$index, correlation$beta[,2])
c.obj
```

And input the computed correlation in `RedRibbon`

```{r use correlation} 
rr <- RedRibbon(df, enrichment_mode="hyper-two-tailed", correlation=c.obj)
quad <- quadrants(rr, algorithm="ea", permutation=TRUE, whole=FALSE)
gg <- ggRedRibbon(rr, quadrants=quad,
		  repel.force = 250) +
   coord_fixed(ratio = 1, clip = "off")
gg

```

Considering gene correlations, the adjusted p-value of the overlap is not significant. Hence, no minimal coordinate is shown on the map.

<a name="realdataset"/>

# Analysis with a real dataset

To demonstrate the capabilities of `RedRibbon`, we will use the data from a ([real example.](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE159984)) Briefly, the data contains the output from 2 different differential expression analysis obtained with `DeSeq2`.

```{r mergeT2DD8PG}
data("T2D-D8PG", package = "RedRibbon")

df.real <- merge(T2DvsCTL[, c("ensembl_id", "log2FoldChange")],
                 D8PGvsCTL[, c("ensembl_id", "log2FoldChange")],
		 by = "ensembl_id")
colnames(df.real) <- c("id", "a", "b")
head(df.real) %>%
  kbl() %>%
  kable_styling(latex_options = "hold_position")
```

Once the data is formatted, we can run `RedRibbon`:

```{r RedRibbonT2DD8PG}
rr <- RedRibbon(df.real, enrichment_mode="hyper-two-tailed")
quad <- quadrants(rr, algorithm="ea", permutation=TRUE, whole=FALSE)
gg <- ggRedRibbon(rr, quadrants=quad,
      		  labels = c("T2D vs CTL", "D8PG vs CTL"),
		  repel.force = 250) +
   coord_fixed(ratio = 1, clip = "off")
gg

```

# sessionInfo()

```{r sessionInfo} 
sessionInfo()
```
